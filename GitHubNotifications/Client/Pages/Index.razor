@page "/"
@inject IJSRuntime JS;
@inject NavigationManager NavigationManager
@inject HostAuthenticationStateProvider AuthStateProvider
@inject HttpClient Http
@using Microsoft.AspNetCore.SignalR.Client

<AuthorizeView>
    <Authorized>
        Notifications: @permission, Hub connected: @IsConnected
        <h2>Comments</h2>
            <div id="commentList" class="list-group" style="overflow-wrap: anywhere;">
                @foreach (var comment in commentLookup.Values.OrderByDescending(c => c.created))
                {
                    <CommentItem Comment="@comment"></CommentItem>
                }
            </div>
        <h2>Check Failures</h2>
        <ul id="messagesList">
            @foreach (var message in checks)
            {
                <li>@message</li>
            }
        </ul>
    </Authorized>
    <NotAuthorized>
        <a href="auth/signin">Log in</a>
    </NotAuthorized>
</AuthorizeView>


@code {
    private string permission;
    private string icon = "images/github.png";
    private object notif;

    private async Task RequestPermission()
    {
        try
        {
            await JS.InvokeAsync<object>("requestPermission");
        }
        catch (Exception)
        { }
    }

    private void ClearComments()
    {
        commentLookup.Clear();
        StateHasChanged();
    }

    private void ClearChecks()
    {
        checks.Clear();
        StateHasChanged();
    }

    private async Task CreateNotifcationAsync(DateTime updated, string id, string title, string body, string url)
    {
        @* var options = new
        {
            Body = body,
            Icon = icon,
            Renotify = true, // By default a notification is not overwritten, so there can only be one.
            RequireInteraction = false,
            Tag = id,
            TimeStamp = updated,
            Uri = url
        };
        try
        {
            notif = await JS.InvokeAsync<object>("createNotification", title, options);
        }
        catch (Exception)
        { } *@
    }

    private HubConnection hubConnection;
    private List<string> checks = new(30);
    //private List<Comment> comments = new();
    private Dictionary<string, ClientComment> commentLookup = new();
    private TableClient tableClient = null;
    protected override async Task OnInitializedAsync()
    {       
        permission = await GetPermissionState();
        if (permission != "granted")
        {
            await RequestPermission();
        }

        hubConnection = new HubConnectionBuilder()
        .WithUrl(NavigationManager.ToAbsoluteUri("/notificationshub"))
        .Build();

        hubConnection.On<DateTime, string, string, string, string>("CheckStatus", (updated, id, title, message, url) =>
        {
            var encodedMsg = $"{title}: {message}";
            checks.Add(encodedMsg);
            StateHasChanged();
            CreateNotifcationAsync(updated, id, title, message, url).GetAwaiter().GetResult();
        });

        hubConnection.On<ClientComment>("NewComment", (comment) =>
        {
            AddComment(comment);
            StateHasChanged();
            CreateNotifcationAsync(comment.created,comment.id,comment.title, $"@{comment.author}: {comment.body}",comment.uri).GetAwaiter().GetResult();
        });

        var AuthState = await AuthStateProvider.GetAuthenticationStateAsync();
        if (!IsConnected && AuthState.User.Claims.Any())
        {
            await Connect();
        }

        var stringResult = await Http.GetStringAsync("Comment/GetSasUrl");
        var url = new Uri(stringResult);
        tableClient = new TableClient(url, new AzureSasCredential(url.Query), null);
        await LoadComments();
    }

    async Task LoadComments()
    {
        var ago = DateTime.UtcNow.AddDays(-3);
        await foreach (PRComment comment in tableClient.QueryAsync<PRComment>(c => c.Created >= ago))
        {
            AddComment(new ClientComment{ 
                author = comment.Author,
                body = comment.Body,
                created = comment.Created,
                id = comment.RowKey,
                replyToId = comment.ParentId,
                title = comment.PrTitle,
                uri = comment.Uri });
        }
        StateHasChanged();
    }

    void AddComment(ClientComment comment)
    {
        if (null == comment.replyToId || "0" == comment.replyToId )
        {
            commentLookup[comment.id] = comment;
        }
        else
        {
            if (commentLookup.TryGetValue(comment.replyToId, out var parent))
            {
                parent.replies ??= new List<ClientComment>();
                parent.replies.Add(comment);
                 if (comment.created > parent.sortDate)
                 {
                    parent.sortDate =comment.created;
                 }
            }
            else if (comment.parent != null)
            {
                commentLookup[comment.replyToId] = comment.parent;
                comment.parent.replies = new List<ClientComment>{comment};
            }
        }
    }

    async Task Connect() { await hubConnection.StartAsync(); }

    async Task<string> GetPermissionState() => await JS.InvokeAsync<string>("currentPermission");

    public bool IsConnected =>
    hubConnection?.State == HubConnectionState.Connected;

    public async ValueTask DisposeAsync() { await hubConnection.DisposeAsync(); }
}