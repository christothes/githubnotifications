@page "/"
@inject IJSRuntime JS;
@inject NavigationManager NavigationManager
@inject HostAuthenticationStateProvider AuthStateProvider
@inject HttpClient Http
@using Microsoft.AspNetCore.SignalR.Client

<AuthorizeView>
    <Authorized>
        @* <button @onclick="TestComment">Test Comment</button> *@
        <div class="custom-control custom-switch">
            <input type="checkbox" id="prOption" class="custom-control-input" @bind="OnlyMyPRs" disabled>
            <label class="custom-control-label" for="prOption">Show only my PRs</label>
        </div>
        <div style="height: 75%;">
            <h2>Comments</h2>
            <div id="commentList" class="list-group" style="overflow-wrap: anywhere;">
                @foreach (var comment in commentLookup.Values.OrderByDescending(c => c.sortDate))
                {
                    <CommentItem Comment="@comment"></CommentItem>
                }
            </div>
        </div>
        <div>
            <h2>Check Failures</h2>
            <ul id="messagesList">
                @foreach (var message in checks)
                {
                    <li>@message</li>
                }
            </ul>
        </div>
    </Authorized>
    <NotAuthorized>
        Please Log in.
    </NotAuthorized>
</AuthorizeView>


@code {
    private string permission;
    private string icon = "images/github.png";
    private object notif;
    private HubConnection hubConnection;
    private List<string> checks = new(30);
    private Dictionary<string, ClientComment> commentLookup = new();
    private TableClient tableClient = null;
    private UserOptions userOptions = null;
    private bool OnlyMyPRs = false;

    private async Task RequestPermission()
    {
        try
        {
            await JS.InvokeAsync<object>("requestPermission");
        }
        catch (Exception)
        { }
    }

    private void ClearComments()
    {
        commentLookup.Clear();
        StateHasChanged();
    }

    private void ClearChecks()
    {
        checks.Clear();
        StateHasChanged();
    }

    private async Task TestComment()
    {
        await Http.GetAsync("Comment/TestComment");
    }

    private async Task CreateNotifcationAsync(DateTime updated, string id, string title, string body, string url)
    {
        var options = new
        {
            Body = body,
            Icon = icon,
            Renotify = true, // By default a notification is not overwritten, so there can only be one.
            RequireInteraction = false,
            Tag = id,
            TimeStamp = updated,
            Uri = url
        };
        try
        {
            notif = await JS.InvokeAsync<object>("createNotification", title, options);
        }
        catch (Exception)
        { }
    }
    
    protected override async Task OnInitializedAsync()
    {       
        var AuthState = await AuthStateProvider.GetAuthenticationStateAsync();
        permission = await GetPermissionState();
        if (permission != "granted")
        {
            await RequestPermission();
        }

        hubConnection = new HubConnectionBuilder()
        .WithUrl(NavigationManager.ToAbsoluteUri("/notificationshub"))
        .Build();

        hubConnection.On<DateTime, string, string, string, string, string>("CheckStatus", (updated, id, title, message, url, author) =>
        {
            if (author == AuthState.User.GetGitHubLogin())
            {
                var encodedMsg = $"{title}: {message}";
                checks.Add(encodedMsg);
                StateHasChanged();
                CreateNotifcationAsync(updated, id, title, message, url).GetAwaiter().GetResult();
            }
        });

        hubConnection.On<ClientComment>("NewComment", async (comment) =>
        {
            if (null == comment.parentId || "0" == comment.parentId )
            {
                commentLookup[comment.id] = comment;
            }
            await AddComment(comment);
            StateHasChanged();
            CreateNotifcationAsync(comment.created,comment.id,comment.title, $"@{comment.author}: {comment.body}",comment.uri).GetAwaiter().GetResult();
        });

        
        if (!IsConnected && AuthState.User.Claims.Any())
        {
            await Connect();
        }

        try
        {
            var stringResult = await Http.GetStringAsync("Comment/GetSasUrl");
            userOptions = await Http.GetFromJsonAsync<UserOptions>("User/GetOptions");
            OnlyMyPRs = userOptions?.OnlyMyPRs ?? false;
            StateHasChanged();
            var url = new Uri(stringResult);
            tableClient = new TableClient(url, new AzureSasCredential(url.Query), null);
            await LoadComments(AuthState.User.GetGitHubLogin());

        } catch {}
    }

    async Task LoadComments(string user)
    {
        var comments = new List<ClientComment>();
        var ago = DateTime.UtcNow.AddDays(-2);
        Expression<Func<PRComment, bool>> filter = c => c.Created >= ago;
        if (userOptions?.OnlyMyPRs ?? false)
        {
            filter = c => c.Created >= ago && c.PartitionKey == user;
        }
        await foreach (PRComment comment in tableClient.QueryAsync<PRComment>(filter))
        {
            var cc = new ClientComment { 
                prAuthor = comment.PartitionKey,
                author = comment.Author,
                body = comment.Body,
                created = comment.Created.ToLocalTime(),
                id = comment.RowKey,
                parentId = comment.ParentId,
                parentAuthor = comment.ParentAuthor,
                title = comment.PrTitle,
                uri = comment.Uri,
                sortDate = comment.Created.ToLocalTime()};

            comments.Add(cc);

            if (null == cc.parentId || "0" == cc.parentId )
            {
                commentLookup[cc.id] = cc;
            }
        }

        foreach(var comment in comments)
        {
            await AddComment(comment);
        }
        StateHasChanged();
    }

    async Task AddComment(ClientComment comment)
    {
        comment.sortDate = comment.created.ToLocalTime();
        comment.created = comment.sortDate;
        if (comment.parentId != "0" && comment.parentId != null && commentLookup.TryGetValue(comment.parentId, out var parent))
        {
            parent.replies ??= new List<ClientComment>();
            parent.replies.Add(comment);
            if (comment.created > parent.sortDate)
            {
                parent.sortDate = comment.created;
            }
        }
    }

    async Task Connect() { await hubConnection.StartAsync(); }

    async Task<string> GetPermissionState() => await JS.InvokeAsync<string>("currentPermission");

    public bool IsConnected =>
    hubConnection?.State == HubConnectionState.Connected;

    public async ValueTask DisposeAsync() { await hubConnection.DisposeAsync(); }
}